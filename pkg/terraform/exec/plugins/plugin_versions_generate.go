// +build tools

package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"golang.org/x/mod/modfile"
	"golang.org/x/mod/module"
)

type TFPluginInfo struct {
	Module  module.Version
	Name    string
	Tag     string
	Version string
}

type TFPlugins struct {
	Pkg          string
	TFPluginInfo []TFPluginInfo
}

func getTemplate() string {
	return `// Code generated by plugin_versions_generate.go; DO NOT EDIT.

package {{ .Pkg }}

{{ with .TFPluginInfo }}
        {{- range . }}

func Get{{ .Name }}Version() string {
	return "{{ .Version }}"
}

        {{- end }}
{{- end}}
`
}

// getTerraformPluginInfo finds terraform providers used in go.mod, does any
// necessary replacements and saves into our plugin map.
func getTerraformPluginInfo(file *modfile.File, plugins *map[string]*TFPluginInfo) {

	// terraform provider and name regex
	re := regexp.MustCompile(`^[[:alnum:]][[:alnum:]\.\-/]+(terraform-provider-([[:alnum:]]+))`)

	// Find all terraform providers
	for _, r := range file.Require {
		matches := re.FindStringSubmatch(r.Mod.Path)
		if len(matches) == 3 {
			(*plugins)[matches[1]] = &TFPluginInfo{
				Module: r.Mod,
				Name:   matches[2],
			}
		}
	}

	// Update replaced terraform providers
	for _, r := range file.Replace {
		matches := re.FindStringSubmatch(r.Old.Path)
		if len(matches) == 3 {
			(*plugins)[matches[1]] = &TFPluginInfo{
				Module: r.New,
				Name:   matches[2],
			}
		}
	}
}

// getTerraformPluginVersions gathers the terraform provider version numbers
func getTerraformPluginVersions(file *modfile.File, plugins *map[string]*TFPluginInfo) {

	// Output regex - clean up git name-rev output
	ore := regexp.MustCompile(`[[:space:]]+|\^[[:digit:]]+`)

	// Tag regex - match the git tag and hash
	tre := regexp.MustCompile(`[[:digit:]]{14}-([a-fA-F0-9]{12})$`)

	// URL regex - chop off anything after the terraform provider name
	ure := regexp.MustCompile(`^(.+terraform-provider-[[:alnum:]]+)/v[[:digit:]]+`)

	// Version regex - chop off anything that is not the version
	vre := regexp.MustCompile(`([0-9\.]+)`)

	for p, pi := range *plugins {
		var repo *git.Repository
		var mod *module.Version = &pi.Module

		// XXX: we assume https checkouts
		url := fmt.Sprintf("https://%s", mod.Path)

		// If this is a v2 or up  module, chop off the end
		matches := ure.FindStringSubmatch(mod.Path)
		if len(matches) == 2 {
			url = fmt.Sprintf("https://%s", matches[1])
		}

		// git clone if directory doesn't exist, else git pull
		tmpDir := filepath.Join("tmp", p)
		if _, err := os.Stat(tmpDir); os.IsNotExist(err) {
			os.MkdirAll(tmpDir, 0700)
			repo, err = git.PlainClone(tmpDir, false, &git.CloneOptions{
				URL:      url,
				Progress: os.Stdout,
			})
			if err != nil {
				log.Fatal("failed to clone repo ", url)
			}
		} else {
			repo, err = git.PlainOpen(tmpDir)
			if err != nil {
				log.Fatal("failed to open repo ", tmpDir)
			}
			worktree, err := repo.Worktree()
			if err != nil {
				log.Fatal(err)
			}
			err = worktree.Pull(&git.PullOptions{})
			if err != nil && err != git.NoErrAlreadyUpToDate {
				log.Fatal(err)
			}
		}

		pi.Tag = mod.Version

		// If the version is a pseudo version, get the commit hash and
		// resolve it to a tag if one exists, else default to v1.0.0
		matches = tre.FindStringSubmatch(mod.Version)
		if len(matches) == 2 {
			h := matches[1]
			hash, err := repo.ResolveRevision(plumbing.Revision(h))
			if err != nil {
				log.Fatal(err)
			}

			here, err := os.Getwd()
			if err != nil {
				log.Fatal(err)
			}
			err = os.Chdir(tmpDir)
			if err != nil {
				log.Fatal(err)
			}
			// XXX: HACK: fork git process until go-git supports name-rev
			out, err := exec.Command("git", "name-rev", "--tags", "--name-only", hash.String()).Output()
			if err != nil {
				log.Fatal(err)
			}

			// XXX:  What should be the default here?
			tag := ore.ReplaceAllString(string(out), "")
			if tag == "undefined" {
				tag = "v1.0.0"
			}
			pi.Tag = tag

			err = os.Chdir(here)
			if err != nil {
				log.Fatal(err)
			}
		}

		// Extract version out of tag
		pi.Version = vre.FindString(pi.Tag)
	}
}

// getLocalTerraformPluginVersions gathers the terraform provider version
// numbers for local plugins
func getLocalTerraformPluginVersions(file *modfile.File, plugins *map[string]*TFPluginInfo) {
	(*plugins)["azureprivatedns"] = &TFPluginInfo{
		Name:    "azureprivatedns",
		Tag:     "v1.0.0",
		Version: "1.0.0",
	}
	(*plugins)["vsphereprivateprovider"] = &TFPluginInfo{
		Name:    "vsphereprivateprovider",
		Tag:     "v1.0.0",
		Version: "1.0.0",
	}
}

func main() {
	if len(os.Args) != 3 {
		log.Fatal("usage: ", filepath.Base(os.Args[0]), " <go.mod> <output>")
	}

	// Get absolute paths for file arguments
	goMod, err := filepath.Abs(os.Args[1])
	if err != nil {
		log.Fatal("failed to get absolute path of go.mod")
	}
	outFile, err := filepath.Abs(os.Args[2])
	if err != nil {
		log.Fatal("failed to get absolute path of output file")
	}

	// Read and parse go module into file object
	mod, err := ioutil.ReadFile(goMod)
	if err != nil {
		log.Fatal(err)
	}
	file, err := modfile.Parse(goMod, mod, nil)
	if err != nil {
		log.Fatal(err)
	}

	plugins := make(map[string]*TFPluginInfo)

	// Read in plugin metadata into our plugin map
	getTerraformPluginInfo(file, &plugins)

	// Get the versions for all of the terraform plugins and update our map
	getTerraformPluginVersions(file, &plugins)

	// Get local plugin versions
	getLocalTerraformPluginVersions(file, &plugins)

	// We have everything, insert into tfplugins for template expansion
	tfplugins := &TFPlugins{Pkg: "plugins"}
	for _, pi := range plugins {
		pi.Name = fmt.Sprintf("%s%s", strings.ToUpper(string(pi.Name[0])), strings.ToLower(pi.Name[1:]))
		tfplugins.TFPluginInfo = append(tfplugins.TFPluginInfo, *pi)
	}
	buf := &bytes.Buffer{}

	// Render template with plugin data into a buffer
	t := template.Must(template.New("plugin_versions").Parse(getTemplate()))
	if err := t.Execute(buf, tfplugins); err != nil {
		log.Fatalln(fmt.Errorf("failed to execute the template: %v", err))
	}

	// Write out the template
	if err := ioutil.WriteFile(outFile, buf.Bytes(), 0664); err != nil {
		log.Fatal(err)
	}
}
